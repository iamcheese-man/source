-- ðŸš€ Advanced Stealth Adonis Bypass (Require-Hook + Remote Filter)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

-- Extended list of known dangerous Adonis commands (case-insensitive)
local bad = {
    "crash", "cpucrash", "gpucrash", "shutdown", "softshutdown",
    "kick", "softkick", "seize", "blockinput", "break", "lock",
    "setcore", "serverkick", "servershutdown", "ban", "mute",
    "freeze", "teleportkill", "forcereset", "crashclient",
    "crashserver", "memoryleak", "blackscreen", "kickall",
    "log", "copy", "reset", "clear", "disconnect", "delete",
    "nil", "control", "view", "explorer", "deletecharacter",
    "notadmin", "removetools", "spinhax", "corrupt", "blind",
    "sit", "remove", "tools", "void", "teleport", "shutdownclient",
    "teleportplayer", "controlplayer", "logoutput", "console",
    "error", "warn", "systemmessage", "disablecontrols",
    "crashgui", "crashgame", "taskcrash", "freezeclient",
    "performancekill", "debughook", "hookbreak", "destroy",
    "clearworkspace", "blockchat", "kill"
}

-- Check if a string matches a bad command (case-insensitive)
local function isBad(cmd)
    if type(cmd) ~= "string" then return false end
    cmd = cmd:lower()
    for i = 1, #bad do
        if cmd == bad[i] then return true end
    end
    return false
end

-- Neutralize a module table in place
local function neutralizeModule(modTable)
    if type(modTable) ~= "table" then return end
    for name, fn in pairs(modTable) do
        if isBad(name) and type(fn) == "function" then
            modTable[name] = function(...) return nil end
        end
    end
end

-- 1) Override require() to catch Adonis modules on load
do
    local oldRequire = require
    local adonisKeywords = { "adonis", "clientcommands", "security", "modules" }

    _G.require = function(mod)
        local result = oldRequire(mod)
        if typeof(mod) == "Instance" and mod.Name then
            local lname = mod.Name:lower()
            for _, kw in ipairs(adonisKeywords) do
                if lname:find(kw) then
                    pcall(neutralizeModule, result)
                    break
                end
            end
        end
        return result
    end
end

-- 2) Patch any already-loaded Adonis modules
for _, mod in ipairs(getloadedmodules()) do
    if mod.Name:lower():find("adonis") then
        local ok, env = pcall(getsenv, mod)
        if ok then
            neutralizeModule(env)
        end
        local ok2, mt = pcall(getmetatable, mod)
        if ok2 and type(mt) == "table" then
            for k, v in pairs(mt) do
                if type(v) == "function" then
                    mt[k] = function(...) return nil end
                end
            end
        end
    end
end

-- 3) Intercept Adonis command RemoteEvents in ReplicatedStorage
for _, obj in ipairs(ReplicatedStorage:GetDescendants()) do
    if obj:IsA("RemoteEvent") and obj.Name:lower():find("client") then
        obj.OnClientEvent:Connect(function(cmd, ...)
            if isBad(cmd) then
                return
            end
        end)
    end
end
